[{"path":"https://lhdjung.github.io/roundwork/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 roundwork authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://lhdjung.github.io/roundwork/articles/rounding-in-depth.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Rounding in depth","text":"Base R’s round() function surprisingly sophisticated. distinguishes simpler rounding procedures, rounding 5. reason, however, can’t used reconstruct rounding procedures software programs. job roundwork. First, present reround(), general interface reconstructing rounded numbers, going individual rounding functions. also discuss unround(), works reverse way: takes rounded number reconstructs bounds original number, taking details assumed rounding procedure account. Finally, take closer look bias rounding raw numbers.","code":""},{"path":"https://lhdjung.github.io/roundwork/articles/rounding-in-depth.html","id":"reconstruct-rounded-numbers-with-reround","dir":"Articles","previous_headings":"","what":"Reconstruct rounded numbers with reround()","title":"Rounding in depth","text":"None error detection techniques errorverse calls individual rounding functions directly. Instead, call reround(), mediates two levels. reround() takes vector “raw” reconstructed numbers yet rounded way ’s assumed original rounding procedure. next argument digits, number decimal places round . remaining three arguments rounding procedure. time, rounding interest. takes string name one rounding procedures discussed . example reround() call: two remaining arguments mostly forgettable: concern obscure cases rounding threshold 5 (threshold) rounding absolute values positive negative numbers (symmetric). Ignore otherwise.","code":"reround(x = c(5.812, 7.249), digits = 2, rounding = \"up\") #> [1] 5.81 7.25"},{"path":[]},{"path":"https://lhdjung.github.io/roundwork/articles/rounding-in-depth.html","id":"up-and-down","dir":"Articles","previous_headings":"Rounding procedures in detail","what":"Up and down","title":"Rounding in depth","text":"round_up() people think rounding. decimal portion cut rounding 5 greater, rounds . Otherwise, rounds . Rounding 5 actually special case round_up_from(), can take numeric threshold, just 5: two functions mirror images round_down() round_down_from(). arguments round_up(): round_down_from(), , just reverse round_up_from(): Rounding implements formula: ⌊x(10d)+1−t10⌋10d \\frac{\\lfloor x(10^d) +1 - \\frac{t}{10} \\rfloor}{10^d} xx number rounded, dd number decimal places xx rounded, tt threshold rounding (e.g., t=5t = 5 rounding 5). Note ⌊n⌋\\lfloor n \\rfloor floors number nn, ⌈n⌉\\lceil n \\rceil ceils . Rounding works accordingly. Note ++ −- reversed : ⌈x(10d)−1+t10⌉10d \\frac{\\lceil x(10^d) - 1 + \\frac{t}{10} \\rceil}{10^d}","code":"round_up(x = 1.24, digits = 1) #> [1] 1.2  round_up(x = 1.25, digits = 1) #> [1] 1.3  round_up(x = 1.25)  # default for `digits` is 0 #> [1] 1 round_up_from(x = 4.28, digits = 1, threshold = 9) #> [1] 4.2  round_up_from(x = 4.28, digits = 1, threshold = 1) #> [1] 4.3 round_down(x = 1.24, digits = 1) #> [1] 1.2  round_down(x = 1.25, digits = 1) #> [1] 1.2  round_down(x = 1.25)  # default for `digits` is 0 #> [1] 1 round_down_from(x = 4.28, digits = 1, threshold = 9) #> [1] 4.3  round_down_from(x = 4.28, digits = 1, threshold = 1) #> [1] 4.2"},{"path":"https://lhdjung.github.io/roundwork/articles/rounding-in-depth.html","id":"to-even-base-r","dir":"Articles","previous_headings":"Rounding procedures in detail","what":"To even (base R)","title":"Rounding in depth","text":"Like Python’s round() function, R’s base::round() doesn’t round , use procedure based solely truncated part number. Instead, round() strives round next even number. also called “banker’s rounding”, follows technical standard, IEEE 754. Realizing round() works highly unintuitive way sometimes leads consternation. can’t just round like learned school, , 5? reason seems bias. 5 right two whole numbers, procedure rounds 5 predetermined direction introduces bias toward direction. Rounding 5 therefore biased upward, rounding 5 biased downward. shown Rounding bias section , unlikely major issue rounding raw numbers originally many decimal places. might serious, however, initial number decimal places low (whatever reason) need precision high. least theory, “rounding even” biased either direction, preserves mean original distribution. round() aims operate. case works , whereas bias rounding fully apparent: However, noble goal unbiased rounding runs reality floating point arithmetic. might therefore get results round() first seem bizarre, least unpredictable. Consider: Sometimes round() behaves just , times, results can hard explain. Martin Mächler, wrote present version round(), describes issue follows: reason behavior decimal fractions can’t, fact, represented double precision numbers. Even seemingly “clean” numbers decimal places come long invisible mantissa, therefore closer one side . (see clearly, try entering decimal numbers Float Exposed.) usually think rounding rules breaking tie occurs 5. floating-point numbers, however, just somewhat less greater 5. tie! Consequently, Mächler says, rounding functions need “measure, guess two possible decimals closer x” — therefore, way round. seems better following mathematical intuitions may always correspond way computers actually deal numbers. R used present solution since version 4.0.0. base::round() black box, seems unbiased long run. recommend using original work, even though quite different rounding procedures — therefore unsuitable reconstructing . Instead, need functions like roundwork.","code":"vec1 <- seq(from = 0.5, to = 9.5) up1 <- round_up(vec1) down1 <- round_down(vec1) even1 <- round(vec1)  vec1 #>  [1] 0.5 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5 up1 #>  [1]  1  2  3  4  5  6  7  8  9 10 down1 #>  [1] 0 1 2 3 4 5 6 7 8 9 even1 #>  [1]  0  2  2  4  4  6  6  8  8 10  # Original mean mean(vec1) #> [1] 5  # Means when rounding up or down: bias! mean(up1) #> [1] 5.5 mean(down1) #> [1] 4.5  # Mean when rounding to even: no bias mean(even1) #> [1] 5 vec2 <- seq(from = 4.5, to = 10.5)  up2 <- round_up(vec2) down2 <- round_down(vec2) even2 <- round(vec2)  vec2 #> [1]  4.5  5.5  6.5  7.5  8.5  9.5 10.5 up2 #> [1]  5  6  7  8  9 10 11 down2 #> [1]  4  5  6  7  8  9 10  even2  # No symmetry here... #> [1]  4  6  6  8  8 10 10  mean(vec2) #> [1] 7.5 mean(up2) #> [1] 8 mean(down2) #> [1] 7 mean(even2)  # ... and the mean is slightly biased downward! #> [1] 7.428571   vec3 <- c(   1.05, 1.15, 1.25, 1.35, 1.45,   1.55, 1.65, 1.75, 1.85, 1.95 )  # No bias here, though: round(vec3, 1) #>  [1] 1.0 1.1 1.2 1.4 1.4 1.6 1.6 1.8 1.9 2.0 mean(vec3) #> [1] 1.5 mean(round(vec3, 1)) #> [1] 1.5"},{"path":"https://lhdjung.github.io/roundwork/articles/rounding-in-depth.html","id":"ieee-754-rounding-standard","dir":"Articles","previous_headings":"Rounding procedures in detail","what":"IEEE 754 rounding standard","title":"Rounding in depth","text":"need follow IEEE 754 rounding standard, see round_ties_to_even() handy wrapper functions implement five IEEE rounding procedures (“rounding-direction attributes”). IEEE 754 defines standards floating-point operations, includes rounding (IEEE 2019, pp. 27f.; Wikipedia page accessible). IEEE 754 functions implemented wrappers around rounding functions. roundwork originally written without standard mind. However, might useful functions explicitly refer standard.","code":""},{"path":"https://lhdjung.github.io/roundwork/articles/rounding-in-depth.html","id":"reconstruct-rounding-bounds-with-unround","dir":"Articles","previous_headings":"","what":"Reconstruct rounding bounds with unround()","title":"Rounding in depth","text":"Rounding leads loss information. mantissa cut part full, resulting number underdetermined respect original number: latter can’t inferred former. might interest, however, compute range original number given rounded number (especially number decimal places rounded) presumed rounding method. ’s often easy infer range, better computer . Enter unround(). returns lower upper bounds, says whether bounds inclusive — something varies greatly rounding procedure. Currently, unround() used helper within scrutiny’s DEBIT implementation. default rounding procedure unround() \"up_or_down\": complete list featured rounding procedures, see documentation unround(), section Rounding. left, range column displays pithy graphical overview columns (except rounding) order: lower lower bound original number. incl_lower TRUE lower bound inclusive FALSE otherwise. x input value. incl_upper TRUE upper bound inclusive FALSE otherwise. upper upper bound original number. default, decimal places counted internally function always operates appropriate decimal level. creates need take trailing zeros account, x needs string: Alternatively, function uses unround() helper might count decimal places (.e., internally calling scrutiny::decimal_places()). pass numbers unround() via decimals argument instead letting redundantly count decimal places second time. case, x can numeric trailing zeros longer needed. (, turn, responsibility count decimal places number-strings rather numeric values shifts unround() higher-level function.) following call returns exact tibble : Since x vectorized, might test several reported numbers :","code":"unround(x = \"8.0\") #> # A tibble: 1 × 7 #>   range                  rounding   lower incl_lower x     incl_upper upper #>   <chr>                  <chr>      <dbl> <lgl>      <chr> <lgl>      <dbl> #> 1 7.95 <= x(8.0) <= 8.05 up_or_down  7.95 TRUE       8.0   TRUE        8.05 unround(x = \"3.50\", rounding = \"up\") #> # A tibble: 1 × 7 #>   range                    rounding lower incl_lower x     incl_upper upper #>   <chr>                    <chr>    <dbl> <lgl>      <chr> <lgl>      <dbl> #> 1 3.495 <= x(3.50) < 3.505 up        3.50 TRUE       3.50  FALSE       3.50 unround(x = 3.5, digits = 2, rounding = \"up\") #> # A tibble: 1 × 7 #>   range                   rounding lower incl_lower     x incl_upper upper #>   <chr>                   <chr>    <dbl> <lgl>      <dbl> <lgl>      <dbl> #> 1 3.495 <= x(3.5) < 3.505 up        3.50 TRUE         3.5 FALSE       3.50 vec2 <- c(\"2.0\", \"3.1\", \"3.5\")  vec2 %>%    unround(rounding = \"even\") #> # A tibble: 3 × 7 #>   range                  rounding lower incl_lower x     incl_upper upper #>   <chr>                  <chr>    <dbl> <lgl>      <chr> <lgl>      <dbl> #> 1 1.95 NA x(2.0) NA 2.05 even      1.95 NA         2.0   NA          2.05 #> 2 3.05 NA x(3.1) NA 3.15 even      3.05 NA         3.1   NA          3.15 #> 3 3.45 NA x(3.5) NA 3.55 even      3.45 NA         3.5   NA          3.55"},{"path":"https://lhdjung.github.io/roundwork/articles/rounding-in-depth.html","id":"fractional-rounding","dir":"Articles","previous_headings":"","what":"Fractional rounding","title":"Rounding in depth","text":"want round numbers fraction instead integer? Check reround_to_fraction() reround_to_fraction_level(): function rounds 0.4 0.5 ’s closest fraction 2. inspired janitor::round_to_fraction(), credit core implementation goes . reround_to_fraction() blends janitor’s fractional rounding flexibility precision reround() provides. ’s , reround_to_fraction_level() rounds nearest fraction decimal level specified via digits argument: two functions currently part error detection workflow.","code":"reround_to_fraction(x = 0.4, denominator = 2, rounding = \"up\") #> [1] 0.5 reround_to_fraction_level(   x = 0.777, denominator = 5, digits = 0, rounding = \"down\" ) #> [1] 0.8 reround_to_fraction_level(   x = 0.777, denominator = 5, digits = 1, rounding = \"down\" ) #> [1] 0.78 reround_to_fraction_level(   x = 0.777, denominator = 5, digits = 2, rounding = \"down\" ) #> [1] 0.776"},{"path":"https://lhdjung.github.io/roundwork/articles/rounding-in-depth.html","id":"rounding-bias","dir":"Articles","previous_headings":"","what":"Rounding bias","title":"Rounding in depth","text":"wrote rounding 5 biased. However, points wider problem: true rounding procedure doesn’t take active precautions bias. base::round() , recommend original work (opposed reconstruction). might useful general flexible way quantify far rounding biases distribution, compared looked like rounding. function rounding_bias() fulfills role. wrapper around reround(), can access rounding procedure reround() can, takes arguments. However, default rounding \"\" instead \"up_or_down\" rounding_bias() makes sense single rounding procedures. general, bias due rounding computed subtracting original distribution rounded one: bias=xrounded−x bias = x_{rounded} - x default, mean computed reduce bias single data point: Set mean FALSE return whole vector individual biases instead: Admittedly, example somewhat overdramatic. rather harmless one: responsible difference? seems (1) sample size (2) number decimal places vector rounded. rounding method doesn’t appear matter numbers many decimal places rounded:  However, raw values preliminarily rounded 2 decimal places rounding proceeds , picture different:  sum, function allows users quantify degree rounding biases distribution, can assess relative merits different rounding procedures. partly sensitize readers potential bias edge cases, also enable make informed rounding decisions .","code":"vec3 <- seq(from = 0.6, to = 0.7, by = 0.01)  vec3 #>  [1] 0.60 0.61 0.62 0.63 0.64 0.65 0.66 0.67 0.68 0.69 0.70  # The mean before rounding... mean(vec3) #> [1] 0.65  # ...is not the same as afterwards... mean(round_up(vec3)) #> [1] 1  # ...and the difference is bias: rounding_bias(x = vec3, digits = 0, rounding = \"up\") #> [1] 0.35 rounding_bias(x = vec3, digits = 0, rounding = \"up\", mean = FALSE) #>  [1] 0.40 0.39 0.38 0.37 0.36 0.35 0.34 0.33 0.32 0.31 0.30 vec4 <- rnorm(50000, 100, 15)  rounding_bias(vec4, digits = 2) #> [1] 1.254758e-05 #> # A tibble: 10 × 3 #>             bias decimal_digits rounding #>            <dbl> <chr>          <chr>    #>  1 0.00000925    1 up           up       #>  2 0.0000125     2 up           up       #>  3 0.00000117    3 up           up       #>  4 0.0000000596  4 up           up       #>  5 0.00000000342 5 up           up       #>  6 0.00000925    1 even         even     #>  7 0.0000125     2 even         even     #>  8 0.00000117    3 even         even     #>  9 0.0000000596  4 even         even     #> 10 0.00000000342 5 even         even #> # A tibble: 10 × 3 #>         bias decimal_digits rounding #>        <dbl> <chr>          <chr>    #>  1 0.00491   1 up           up       #>  2 0         2 up           up       #>  3 0         3 up           up       #>  4 0         4 up           up       #>  5 0         5 up           up       #>  6 0.0000178 1 even         even     #>  7 0         2 even         even     #>  8 0         3 even         even     #>  9 0         4 even         even     #> 10 0         5 even         even"},{"path":"https://lhdjung.github.io/roundwork/articles/rounding-in-depth.html","id":"citation-dummy","dir":"Articles","previous_headings":"Rounding bias","what":"Citation dummy","title":"Rounding in depth","text":"(extra section. display suppressed via CSS element display: none; purpose generate citation IEEE (2019) — want style citation text flexibly format allows (without parentheses) still get reference pasted bottom.)","code":""},{"path":[]},{"path":"https://lhdjung.github.io/roundwork/articles/rounding-options.html","id":"in-the-errorverse","dir":"Articles","previous_headings":"","what":"In the errorverse","title":"Rounding options","text":"options return two rounded numbers input number. consistency tests, means counting value set consistent reported number matches either two rounded reconstructed numbers. \"up_or_down\" (default): one number rounded 5, one 5; order. \"up_from_or_down_from\": one number rounded , one — 5. Instead, specify threshold number input rounded. \"ceiling_or_floor\": one number ceiled, one floored. contrast, options return one rounded number per input: \"even\" rounds next even number, using base R’s round(). See note . \"\" \"\" rounds specified direction, starting 5. \"up_from\" \"down_from\" rounds specified direction, starting number 5. Specify number via threshold argument. \"ceiling\" \"floor\" always rounds next higher lower decimal place, respectively. \"trunc\" \"anti_trunc\" always round towards zero away .","code":""},{"path":"https://lhdjung.github.io/roundwork/articles/rounding-options.html","id":"rounding-at-5-in-other-software","dir":"Articles","previous_headings":"","what":"Rounding at 5 in other software","title":"Rounding options","text":"decimal portion cut rounding 5, technologies round? Python’s standard rounding function rounds even. SPSS rounds even default, users may choose round instead. Matlab rounds away zero default (.e., rounds input positive). However, rounding procedures can chosen. SAS, ROUND() rounds , ROUNDE() rounds even. small tolerance. ROUNDZ() rounds even without tolerance. Stata seemingly rounds even, documentation explicit. Excel, ROUND() rounds 5, ROUNDUP() ceils number, ROUNDDOWN() floors .1","code":""},{"path":"https://lhdjung.github.io/roundwork/articles/rounding-options.html","id":"note-on-rounding-to-even","dir":"Articles","previous_headings":"","what":"Note on rounding to even","title":"Rounding options","text":"Rounding next even number reliable. fundamental facts floating-point computation imply results may vary unpredictable ways. See explanation base::round(), general article limits floating-point arithmetic.","code":""},{"path":"https://lhdjung.github.io/roundwork/articles/scrutiny.html","id":"resolving-conflicts","dir":"Articles","previous_headings":"","what":"Resolving conflicts","title":"Relation to scrutiny","text":"Make sure roundwork functions used instead scrutiny counterparts names. , use conflicted package: can run round_up without parentheses check namespace signature bottom. says namespace:roundwork, everything fine. , please open issue.","code":""},{"path":"https://lhdjung.github.io/roundwork/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Lukas Jung. Author, maintainer.","code":""},{"path":"https://lhdjung.github.io/roundwork/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Jung L (2024). roundwork: Rounding infrastructure. R package version 0.0.1, https://github.com/lhdjung/roundwork/, https://lhdjung.github.io/roundwork/.","code":"@Manual{,   title = {roundwork: Rounding infrastructure},   author = {Lukas Jung},   year = {2024},   note = {R package version 0.0.1, https://github.com/lhdjung/roundwork/},   url = {https://lhdjung.github.io/roundwork/}, }"},{"path":"https://lhdjung.github.io/roundwork/index.html","id":"roundwork","dir":"","previous_headings":"","what":"Rounding for error detection","title":"Rounding for error detection","text":"goal roundwork enable flexible rounding beyond base::round(). main API reround(), implemented rounding procedures can accessed. useful reconstruct others may rounded data. Given rounded number, call unround() get lower upper bounds original number. also takes rounding options account, just like reround() . Many roundwork functions used part scrutiny. outsourced better modularity within errorverse.","code":""},{"path":"https://lhdjung.github.io/roundwork/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Rounding for error detection","text":"can install development version roundwork like :","code":"remotes::install_github(\"lhdjung/roundwork\")"},{"path":"https://lhdjung.github.io/roundwork/index.html","id":"get-started","dir":"","previous_headings":"","what":"Get started","title":"Rounding for error detection","text":"Round specific way, e.g., 5: Use reround() round flexibly, especially functions. can specify rounding procedure: Ceil floor numbers certain strong assumptions permitted: default return two numbers — one rounded , one rounded . best conservative assumptions, conclusions won’t hinge edge cases rounding procedures differ.","code":"round_up(4.1679, digits = 2) #> [1] 4.17 reround(4.1679, digits = 2, rounding = \"up\") #> [1] 4.17 reround(4.1679, digits = 2, rounding = \"floor\") #> [1] 4.16 reround(1.275, digits = 2) #> [1] 1.28 1.27"},{"path":"https://lhdjung.github.io/roundwork/index.html","id":"bounds-on-the-unrounded-number","dir":"","previous_headings":"Get started","what":"Bounds on the unrounded number","title":"Rounding for error detection","text":"unround() computes range unknown original number, given rounded version. rounding procedure determines whether bounds inclusive :","code":"unround(\"3.60\") #> # A tibble: 1 × 7 #>   range                     rounding   lower incl_lower x     incl_upper upper #>   <chr>                     <chr>      <dbl> <lgl>      <chr> <lgl>      <dbl> #> 1 3.595 <= x(3.60) <= 3.605 up_or_down  3.60 TRUE       3.60  TRUE        3.60  unround(\"3.60\", rounding = \"up\") #> # A tibble: 1 × 7 #>   range                    rounding lower incl_lower x     incl_upper upper #>   <chr>                    <chr>    <dbl> <lgl>      <chr> <lgl>      <dbl> #> 1 3.595 <= x(3.60) < 3.605 up        3.60 TRUE       3.60  FALSE       3.60  unround(\"3.60\", rounding = \"even\") #> # A tibble: 1 × 7 #>   range                     rounding lower incl_lower x     incl_upper upper #>   <chr>                     <chr>    <dbl> <lgl>      <chr> <lgl>      <dbl> #> 1 3.595 NA x(3.60) NA 3.605 even      3.60 NA         3.60  NA          3.60"},{"path":"https://lhdjung.github.io/roundwork/reference/fractional-rounding.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized rounding to the nearest fraction of a specified denominator — fractional-rounding","title":"Generalized rounding to the nearest fraction of a specified denominator — fractional-rounding","text":"Two functions round numbers specific fractions, just next higher decimal level. inspired janitor::round_to_fraction() feature options reround(): reround_to_fraction() closely follows janitor::round_to_fraction() first rounding fractions whole number, optionally rounding result specific number digits usual way. reround_to_fraction_level() rounds nearest fraction number specific decimal level (.e., number digits), without subsequent rounding. closer conventional rounding functions.","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/fractional-rounding.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized rounding to the nearest fraction of a specified denominator — fractional-rounding","text":"","code":"reround_to_fraction(   x = NULL,   denominator = 1,   digits = Inf,   rounding = \"up_or_down\",   threshold = 5,   symmetric = FALSE )  reround_to_fraction_level(   x = NULL,   denominator = 1,   digits = 0L,   rounding = \"up_or_down\",   threshold = 5,   symmetric = FALSE )"},{"path":"https://lhdjung.github.io/roundwork/reference/fractional-rounding.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized rounding to the nearest fraction of a specified denominator — fractional-rounding","text":"x Numeric. Vector numbers rounded. denominator Numeric (>= 1) . x rounded nearest fraction denominator. Default 1. digits Numeric (whole numbers). reround_to_fraction(): digits specified, values resulting fractional rounding subsequently rounded many decimal places. set \"auto\", internally becomes ceiling(log10(denominator)) + 1, janitor::round_to_fraction(). Default Inf, case subsequent rounding. reround_to_fraction_level(): function round fraction number decimal level specified digits. Default 0. rounding, threshold, symmetric arguments passed reround().","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/fractional-rounding.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalized rounding to the nearest fraction of a specified denominator — fractional-rounding","text":"Numeric vector length x unless rounding either \"up_or_down\", \"up_from_or_down_from\", \"ceiling_or_floor\". cases, always length 2.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/roundwork/reference/fractional-rounding.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized rounding to the nearest fraction of a specified denominator — fractional-rounding","text":"","code":"#`reround_to_fraction()` rounds `0.4` # to `0` if `denominator` is `1`, which # is the usual integer rounding... reround_to_fraction(0.4, denominator = 1, rounding = \"even\") #> [1] 0  # ...but if `denominator` is `2`, it rounds to the nearest # fraction of 2, which is `0.5`: reround_to_fraction(0.4, denominator = 2, rounding = \"even\") #> [1] 0.5  # Likewise with fractions of 3: reround_to_fraction(0.25, denominator = 3, rounding = \"even\") #> [1] 0.3333333  # The default for `rounding` is to round # both up and down, as in `reround()`: reround_to_fraction(0.4, denominator = 2) #> [1] 0.5 0.5  # These two rounding procedures differ # at the tie points: reround_to_fraction(0.25, denominator = 2) #> [1] 0.5 0.0  # `reround_to_fraction_level()`, in contrast, # uses `digits` to determine some decimal level, # and then rounds to the closest fraction at # that level: reround_to_fraction_level(0.12345, denominator = 2, digits = 0) #> [1] 0 0 reround_to_fraction_level(0.12345, denominator = 2, digits = 1) #> [1] 0.1 0.1 reround_to_fraction_level(0.12345, denominator = 2, digits = 2) #> [1] 0.125 0.125"},{"path":"https://lhdjung.github.io/roundwork/reference/ieee-754.html","id":null,"dir":"Reference","previous_headings":"","what":"IEEE 754 rounding standard — ieee-754","title":"IEEE 754 rounding standard — ieee-754","text":"functions implement industry standard IEEE 754: round_ties_to_even() rounds nearest value. equal distance, tends round even number (see base::round() details). round_ties_to_away() rounds nearest value. equal distance, rounds number greater absolute value, .e., number away zero. round_toward_positive() always rounds greater two nearest values. like ceiling given number decimal places. round_toward_negative() always rounds lesser two nearest values. like flooring given number decimal places. round_toward_zero() always rounds number lower absolute value, .e., number closer zero. like truncation given number decimal places.","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/ieee-754.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"IEEE 754 rounding standard — ieee-754","text":"","code":"round_ties_to_even(x, digits = 0, ...)  round_ties_to_away(x, digits = 0)  round_toward_positive(x, digits = 0)  round_toward_negative(x, digits = 0)  round_toward_zero(x, digits = 0)"},{"path":"https://lhdjung.github.io/roundwork/reference/ieee-754.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"IEEE 754 rounding standard — ieee-754","text":"x Numeric. decimal number round. digits Integer. Number digits round x . Default 0. ... round_ties_to_even(). Passed base::round().","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/ieee-754.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"IEEE 754 rounding standard — ieee-754","text":"Numeric. x rounded digits.","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/ieee-754.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"IEEE 754 rounding standard — ieee-754","text":"function names follow official standard except case conventions (IEEE 2019, pp. 27f.; Wikipedia page accessible uses slightly different names). Internally, functions just wrappers around roundwork functions well base::round(). presented easy compliance IEEE 754 standard R.","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/ieee-754.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"IEEE 754 rounding standard — ieee-754","text":"IEEE (2019). IEEE Standard Floating-Point Arithmetic. https://doi.org/10.1109/IEEESTD.2019.8766229","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/ieee-754.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"IEEE 754 rounding standard — ieee-754","text":"","code":"# Round to the nearest value. In case of a tie, # the result is hard to predict but tends to be even: round_ties_to_even(1.25, digits = 1) #> [1] 1.2 round_ties_to_even(-1.25, digits = 1) #> [1] -1.2  # Round to the nearest value. In case of a tie, # round away from zero: round_ties_to_away(1.25, digits = 1) #> [1] 1.3 round_ties_to_away(-1.25, digits = 1) #> [1] -1.3  # Always round to the greater value: round_toward_positive(0.721, digits = 2) #> [1] 0.73 round_toward_positive(-0.721, digits = 2) #> [1] -0.72  # Always round to the lesser value: round_toward_negative(3.249, digits = 2) #> [1] 3.24 round_toward_negative(-3.249, digits = 2) #> [1] -3.25  # Always round toward zero: round_toward_zero(6.38, digits = 1) #> [1] 6.3 round_toward_zero(-6.38, digits = 1) #> [1] -6.3"},{"path":"https://lhdjung.github.io/roundwork/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://lhdjung.github.io/roundwork/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/reround.html","id":null,"dir":"Reference","previous_headings":"","what":"General interface to reconstructing rounded numbers — reround","title":"General interface to reconstructing rounded numbers — reround","text":"reround() takes one intermediate reconstructed values rounds specific way – namely, way supposed rounded originally, process generated reported values. function provides interface scrutiny's rounding functions well base::round(). used helper within scrutiny::grim(), scrutiny::grimmer(), scrutiny::debit(); might find use places consistency testing reconstruction statistical analyses.","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/reround.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"General interface to reconstructing rounded numbers — reround","text":"","code":"reround(   x,   digits = 0L,   rounding = \"up_or_down\",   threshold = 5,   symmetric = FALSE )"},{"path":"https://lhdjung.github.io/roundwork/reference/reround.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"General interface to reconstructing rounded numbers — reround","text":"x Numeric. Vector possibly original values. digits Integer. Number decimal places reported key values (.e., mean percentage within scrutiny::grim(), standard deviation within scrutiny::grimmer()). rounding String. rounding method supposed used originally. See vignette(\"rounding-options\"). Default \"up_or_down\", returns two values: x rounded . threshold Integer. rounding set \"up_from\", \"down_from\", \"up_from_or_down_from\", threshold must set number reconstructed values rounded . Otherwise irrelevant. Default 5. symmetric Logical. Set symmetric TRUE rounding negative numbers \"up_or_down\", \"\", \"\", \"up_from_or_down_from\", \"up_from\", \"down_from\" mirror positive numbers absolute values always equal. Otherwise irrelevant. Default FALSE.","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/reround.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"General interface to reconstructing rounded numbers — reround","text":"Numeric vector length 1 2. (length 1 unless rounding \"up_or_down\", \"up_from_or_down_from\", \"ceiling_or_floor\", case length 2.)","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/reround.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"General interface to reconstructing rounded numbers — reround","text":"reround() internally calls appropriate rounding function(s) determined rounding argument. See vignette(\"rounding-options\") complete list values rounding can take. specific rounding functions , see documentation round_up(), round_ceiling(), base::round().","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/reround.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"General interface to reconstructing rounded numbers — reround","text":"","code":"# You can specify the rounding procedure: reround(4.1679, digits = 2, rounding = \"up\") #> [1] 4.17  # Default is roundding both up and down: reround(4.1679, digits = 2) #> [1] 4.17 4.17"},{"path":"https://lhdjung.github.io/roundwork/reference/rounding-common.html","id":null,"dir":"Reference","previous_headings":"","what":"Common rounding procedures — rounding-common","title":"Common rounding procedures — rounding-common","text":"round_up() rounds 5, round_down() rounds 5. Otherwise, functions work like base::round(). round_up() round_down() special cases round_up_from() round_down_from(), allow users choose custom thresholds rounding , respectively.","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/rounding-common.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Common rounding procedures — rounding-common","text":"","code":"round_up_from(x, digits = 0L, threshold, symmetric = FALSE)  round_down_from(x, digits = 0L, threshold, symmetric = FALSE)  round_up(x, digits = 0L, symmetric = FALSE)  round_down(x, digits = 0L, symmetric = FALSE)"},{"path":"https://lhdjung.github.io/roundwork/reference/rounding-common.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Common rounding procedures — rounding-common","text":"x Numeric. decimal number round. digits Integer. Number digits round x . Default 0. threshold Integer. round_up_from() round_down_from(). Threshold rounding , respectively. Value 5 round_up()'s internal call round_up_from() round_down()'s internal call round_down_from(). symmetric Logical. Set symmetric TRUE rounding negative numbers mirror positive numbers absolute values equal. Default FALSE.","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/rounding-common.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Common rounding procedures — rounding-common","text":"Numeric. x rounded digits.","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/rounding-common.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Common rounding procedures — rounding-common","text":"functions differ base::round() mainly insofar decision rounding 5 based integer portion x (.e., \"rounding even\"). Instead, round_up_from(), decision determined threshold argument rounding , likewise round_down_from(). threshold constant 5 round_up() round_down(). result, functions predictable less prone floating-point number quirks base::round(). Compare round_down() base::round() data frame rounding 5 created Examples section : round_down() yields continuous sequence final digits 0 9, whereas base::round() behaves way can explained floating point issues. However, surprising behavior part base::round() necessarily flaw (see documentation, vignette: https://rpubs.com/maechler/Rounding). present version R (4.0.0 later), base::round() works fine, functions presented meant replace . main purpose helpers within scrutiny reconstruct computations researchers might used different software. See vignette(\"rounding-options\").","code":""},{"path":[]},{"path":"https://lhdjung.github.io/roundwork/reference/rounding-common.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Common rounding procedures — rounding-common","text":"","code":"# Both `round_up()` and `round_down()` work like # `base::round()` unless the closest digit to be # cut off by rounding is 5:     round_up(x = 9.273, digits = 1)     # 7 cut off #> [1] 9.3  round_down(x = 9.273, digits = 1)     # 7 cut off #> [1] 9.3 base::round(x = 9.273, digits = 1)     # 7 cut off #> [1] 9.3     round_up(x = 7.584, digits = 2)     # 4 cut off #> [1] 7.58  round_down(x = 7.584, digits = 2)     # 4 cut off #> [1] 7.58 base::round(x = 7.584, digits = 2)     # 4 cut off #> [1] 7.58   # Here is the borderline case of 5 rounded by # `round_up()`, `round_down()`, and `base::round()`:  original <- c(    # Define example values   0.05, 0.15, 0.25, 0.35, 0.45,   0.55, 0.65, 0.75, 0.85, 0.95 ) tibble::tibble(   # Output table   original,   round_up = round_up(x = original, digits = 1),   round_down = round_down(x = original, digits = 1),   base_round = base::round(x = original, digits = 1) ) #> # A tibble: 10 × 4 #>    original round_up round_down base_round #>       <dbl>    <dbl>      <dbl>      <dbl> #>  1     0.05      0.1        0          0   #>  2     0.15      0.2        0.1        0.1 #>  3     0.25      0.3        0.2        0.2 #>  4     0.35      0.4        0.3        0.3 #>  5     0.45      0.5        0.4        0.4 #>  6     0.55      0.6        0.5        0.6 #>  7     0.65      0.7        0.6        0.7 #>  8     0.75      0.8        0.7        0.8 #>  9     0.85      0.9        0.8        0.8 #> 10     0.95      1          0.9        0.9  # (Note: Defining `original` as `seq(0.05:0.95, by = 0.1)` # would lead to wrong results unless `original` is rounded # to 2 or so digits before it's rounded to 1.)"},{"path":"https://lhdjung.github.io/roundwork/reference/rounding-uncommon.html","id":null,"dir":"Reference","previous_headings":"","what":"Uncommon rounding procedures — rounding-uncommon","title":"Uncommon rounding procedures — rounding-uncommon","text":"Always round , , toward zero, away : round_ceiling() always rounds . round_floor() always rounds . round_trunc() always rounds toward zero. round_anti_trunc() always rounds away zero. (0 rounded 1.) anti_trunc() round otherwise works like round_anti_trunc(). Despite widely used, featured case needed reconstruction.","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/rounding-uncommon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Uncommon rounding procedures — rounding-uncommon","text":"","code":"round_ceiling(x, digits = 0L)  round_floor(x, digits = 0L)  round_trunc(x, digits = 0L)  anti_trunc(x)  round_anti_trunc(x, digits = 0L)"},{"path":"https://lhdjung.github.io/roundwork/reference/rounding-uncommon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Uncommon rounding procedures — rounding-uncommon","text":"x Numeric. decimal number round. digits Integer. Number digits round x . Default 0.","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/rounding-uncommon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Uncommon rounding procedures — rounding-uncommon","text":"Numeric. x rounded digits (except anti_trunc(), digits argument).","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/rounding-uncommon.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Uncommon rounding procedures — rounding-uncommon","text":"round_ceiling(), round_floor(), round_trunc() generalize base R functions ceiling(), floor(), trunc(), include special cases: default value digits, 0, round_* functions equivalent respective base counterparts. last round_* function, round_anti_trunc(), generalizes another function presented : anti_trunc() works like trunc() except moves away 0, rather towards . , whereas trunc() minimizes absolute value x (compared rounding functions), anti_trunc() maximizes . anti_trunc(x) therefore equal trunc(x)  + 1 x positive, trunc(x) - 1 x negative. round_anti_trunc(), , generalizes anti_trunc() just round_ceiling() generalizes ceiling(), etc. Moreover, round_trunc() equivalent round_floor() positive numbers round_ceiling() negative numbers. reverse true round_anti_trunc(): equivalent round_ceiling() positive numbers round_floor() negative numbers.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/roundwork/reference/rounding-uncommon.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Uncommon rounding procedures — rounding-uncommon","text":"","code":"# Always round up: round_ceiling(x = 4.52, digits = 1)        # 2 cut off #> [1] 4.6  # Always round down: round_floor(x = 4.67, digits = 1)          # 7 cut off #> [1] 4.6  # Always round toward 0: round_trunc(8.439, digits = 2)             # 9 cut off #> [1] 8.43 round_trunc(-8.439, digits = 2)            # 9 cut off #> [1] -8.43  # Always round away from 0: round_anti_trunc(x = 8.421, digits = 2)    # 1 cut off #> [1] 8.43 round_anti_trunc(x = -8.421, digits = 2)   # 1 cut off #> [1] -8.43"},{"path":"https://lhdjung.github.io/roundwork/reference/rounding_bias.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute rounding bias — rounding_bias","title":"Compute rounding bias — rounding_bias","text":"Rounding often leads bias, mean rounded distribution different mean original distribution. Call rounding_bias() compute amount bias.","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/rounding_bias.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute rounding bias — rounding_bias","text":"","code":"rounding_bias(   x,   digits,   rounding = \"up\",   threshold = 5,   symmetric = FALSE,   mean = TRUE )"},{"path":"https://lhdjung.github.io/roundwork/reference/rounding_bias.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute rounding bias — rounding_bias","text":"x Numeric string coercible numeric. digits Integer. Number decimal digits x rounded. rounding String. Rounding procedure applied x. See vignette(\"rounding-options\"). Default \"\". threshold, symmetric arguments passed reround(). mean Logical. TRUE (default), mean total bias returned. Set mean FALSE get vector individual biases length x.","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/rounding_bias.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute rounding bias — rounding_bias","text":"Numeric. default mean, length 1; otherwise, length x.","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/rounding_bias.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute rounding bias — rounding_bias","text":"Bias calculated subtracting original vector, x, vector rounded specified way. function passes arguments except mean reround(). , however, rounding \"\" default, set \"up_or_down\", \"up_from_or_down_from\", \"ceiling_or_floor\".","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/rounding_bias.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute rounding bias — rounding_bias","text":"","code":"# Define example vector: vec <- seq(from = 0.01, to = 0.1, by = 0.01) vec #>  [1] 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10  # The default rounds `x` up from 5: rounding_bias(x = vec, digits = 1) #> [1] 0.005  # Other rounding procedures are supported, # such as rounding down from 5... rounding_bias(x = vec, digits = 1, rounding = \"down\") #> [1] -0.005  # ...or rounding to even with `base::round()`: rounding_bias(x = vec, digits = 1, rounding = \"even\") #> [1] -0.005"},{"path":"https://lhdjung.github.io/roundwork/reference/unround.html","id":null,"dir":"Reference","previous_headings":"","what":"Reconstruct rounding bounds — unround","title":"Reconstruct rounding bounds — unround","text":"unround() takes rounded number returns range original value: lower upper bounds hypothetical earlier number later rounded input number. also displays range inequation signs, showing whether bounds inclusive . default, presumed rounding method rounding () 5. See Rounding section methods.","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/unround.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reconstruct rounding bounds — unround","text":"","code":"unround(x, rounding = \"up_or_down\", threshold = 5, digits = NULL)"},{"path":"https://lhdjung.github.io/roundwork/reference/unround.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reconstruct rounding bounds — unround","text":"x String numeric. Rounded number. x must string unless digits specified (likely function uses unround() helper). rounding String. Rounding method presumably used create x. Default \"up_or_down\". , see section Rounding. threshold Integer. Number round . rounding methods affected. Default 5. digits Integer. argument meant make unround() efficient use helper function need redundantly count decimal places. specify otherwise. Default NULL, case decimal places really counted internally x must string.","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/unround.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reconstruct rounding bounds — unround","text":"tibble seven columns: range, rounding, lower, incl_lower, x, incl_upper, upper. range column handy representation information stored columns lower upper, order.","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/unround.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reconstruct rounding bounds — unround","text":"function vectorized x rounding. can useful unround multiple numbers , check single number unrounded different assumed rounding methods. vectors length greater 1, must length. However, pair numbers rounding methods, can confusing. recommended least one input vectors length 1. x need string digits specified? case, unround() must count decimal places . x numeric, trailing zeros get dropped numerics. Trailing zeros important reconstructing boundary values trailing digits . Strings drop trailing zeros, used instead.","code":""},{"path":"https://lhdjung.github.io/roundwork/reference/unround.html","id":"rounding","dir":"Reference","previous_headings":"","what":"Rounding","title":"Reconstruct rounding bounds — unround","text":"Depending x rounded, boundary values can inclusive exclusive. incl_lower incl_upper columns resulting tibble TRUE first case FALSE second. range column reflects equation inequation signs. However, ranges based assumptions way x rounded. Set rounding rounding method hypothetically lead x: Base R's round() (R version >= 4.0.0), referenced rounding = \"even\", reconstructed way \"up_or_down\", whether boundary values inclusive hard predict. Therefore, unround() checks , informs .","code":""},{"path":[]},{"path":"https://lhdjung.github.io/roundwork/reference/unround.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reconstruct rounding bounds — unround","text":"","code":"# By default, the function assumes that `x` # was either rounded up or down: unround(x = \"2.7\") #> # A tibble: 1 × 7 #>   range                  rounding   lower incl_lower x     incl_upper upper #>   <chr>                  <chr>      <dbl> <lgl>      <chr> <lgl>      <dbl> #> 1 2.65 <= x(2.7) <= 2.75 up_or_down  2.65 TRUE       2.7   TRUE        2.75  # If `x` was rounded up, run this: unround(x = \"2.7\", rounding = \"up\") #> # A tibble: 1 × 7 #>   range                 rounding lower incl_lower x     incl_upper upper #>   <chr>                 <chr>    <dbl> <lgl>      <chr> <lgl>      <dbl> #> 1 2.65 <= x(2.7) < 2.75 up        2.65 TRUE       2.7   FALSE       2.75  # Likewise with rounding down... unround(x = \"2.7\", rounding = \"down\") #> # A tibble: 1 × 7 #>   range                 rounding lower incl_lower x     incl_upper upper #>   <chr>                 <chr>    <dbl> <lgl>      <chr> <lgl>      <dbl> #> 1 2.65 < x(2.7) <= 2.75 down      2.65 FALSE      2.7   TRUE        2.75  # ...and with `base::round()` which, broadly # speaking, rounds to the nearest even number: unround(x = \"2.7\", rounding = \"even\") #> # A tibble: 1 × 7 #>   range                  rounding lower incl_lower x     incl_upper upper #>   <chr>                  <chr>    <dbl> <lgl>      <chr> <lgl>      <dbl> #> 1 2.65 NA x(2.7) NA 2.75 even      2.65 NA         2.7   NA          2.75  # Multiple input number-strings return # multiple rows in the output data frame: unround(x = c(3.6, \"5.20\", 5.174)) #> # A tibble: 3 × 7 #>   range                        rounding  lower incl_lower x     incl_upper upper #>   <chr>                        <chr>     <dbl> <lgl>      <chr> <lgl>      <dbl> #> 1 3.55 <= x(3.6) <= 3.65       up_or_do…  3.55 TRUE       3.6   TRUE        3.65 #> 2 5.195 <= x(5.20) <= 5.205    up_or_do…  5.20 TRUE       5.20  TRUE        5.20 #> 3 5.1735 <= x(5.174) <= 5.1745 up_or_do…  5.17 TRUE       5.174 TRUE        5.17"},{"path":"https://lhdjung.github.io/roundwork/news/index.html","id":"roundwork-001","dir":"Changelog","previous_headings":"","what":"roundwork 0.0.1","title":"roundwork 0.0.1","text":"Initial CRAN submission. new package spin-scrutiny. Much code copied ; see Github issue lhdjung/scrutiny#68. unround() longer guesses whether bounds inclusive rounding = \"even\". highly variable underlying base::round() function, firm statement earlier versions scrutiny bounds never inclusive unwarranted. unround() anti_trunc() now correctly throw error rare edge case (rounding unrounding zero assuming \"anti_trunc\" rounding). Five new functions around round_ties_to_even() implement IEEE 754 rounding standard wrapping existing functions.","code":""}]
